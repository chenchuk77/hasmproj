// written by Chen Alkabets / chenchuk@gmail.com
// This file is part of www.nand2tetris.org
// and the book "The Elements of Computing Systems"
// by Nisan and Schocken, MIT Press.
// File name: projects/12/Memory.jack

/**
 * This library provides two services: direct access to the computer's main
 * memory (RAM), and allocation and recycling of memory blocks. The Hack RAM
 * consists of 32,768 words, each holding a 16-bit binary number.
 */ 
class Memory {
    // heap : 2048 - 16383
    // enables access areas outside the heap
    static Array ram;
    //static boolean debugMode;
    static Array heap;
    static int freeList;    // points to the head of allocation list


    /** Initializes the class. */
    function void init(){
        //let debugMode = true;
        // weak typing allow creates an array and initialize directly with addr
        // prevent the needs to call Array ctor that will request maloc, infinitely ...
        let ram = 0;
        let heap = 2048;      // jack spec.
        let freeList = 2048;  // all heap is free
        let heap[0] = 0;      // next
        let heap[1] = 14335;  // len
        return;
    }

    /** Returns the RAM value at the given address. */
    function int peek(int address) {
        return ram[address];
    }

    /** Sets the RAM value at the given address to the given value. */
    function void poke(int address, int value) {
        let ram[address] = value;
        return;
    }

    /** Finds an available RAM block of the given size and returns
     *  a reference to its base address. */
   function int alloc(int size) {
    //----------------------------------------------------------------------------------
    // algorithm is looking for first allocatable space by searching a linked list
    // when found, it checks the next and prev to manage the list in few cases :
    //
    // if head:     only remove from list by moving freeList forward
    // if not head: chaining the prev to the next, unchaining this
    // if tail:     allocating space and may update prev if tail is not the only chain
    //
    //----------------------------------------------------------------------------------
    
        var Array next, prev, block;

        let next = freeList;   // starting poing at head of list
        let prev = freeList;

        // while next is not possible, (loop until possible found)
        while (next[1] < size+2) {
            // if tail, error
            if (next[0] = 0) {
                do Sys.error("6");
            }
            let prev = next;        // save prev
            let next = prev[0];     // check next

        }

        // next is possible
        // if tail - must alloc or fail
        // for alloc(3), need to have block of 5 (ptr,size,data*3)
        //
        if (next[0] = 0) {
            let block = next+2 ;                 // [0] and [1] used (ptr, size)
            let next = next+2 + size;
            let next[0] = freeList[0];           // 0
            let next[1] = freeList[1] - size-2;  // free
            let freeList[1] = size ;             // add size before alloc. will be used by dealloc

            // if tail is head, need to move the head after the block
            if (prev = freeList){
                let freeList = next;
            } else {
            // need to update prev chain ref after allocating a block
                let prev[0] = next;
            }
            return Memory.initialized(block);
        }
        // if head - just remove and point to next
        if (next = freeList) {
            let block = freeList+2;          // [0] and [1] used (ptr, size)
            let freeList = freeList[0];
            return Memory.initialized(block);
        }

        // if not head and not tail, need to chain prev to next-next
        let block = next+2 ;                 // [0] and [1] used (ptr, size)
        let prev[0] = next[0];  // unchain from freelist and return the block
        return Memory.initialized(block);
    }

    // private non-API returns array initied with [0,0,0,0...0]
    function Array initialized(Array block){
        var int i, size;
        // heap offset is 2048. size writen 1 byte before the block
        let size = Memory.peek(block - 1);     
        let i = 0;
        while (i < size) {
            let block[i] = 0;
            let i = i + 1;
        }
        return block;
    }

    /** De-allocates the given object (cast as an array) by making
     *  it available for future allocations. */

    // structured block (ptr,size,n*) already done when alloc called.
    // when dealloc called, this chain need to return to free list
    function void deAlloc(Array o){
        var Array head;
        // adding this chain to head of free list
        let head = o - 2;      // returned block address -1 = size
                               // returned block address -2 = ptr
        let head[0] = freeList;
        let freeList = head;
        return;
    } 

}

